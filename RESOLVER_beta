--B v1.0 [1.1]

local v0={};for v7=1,64 do v0[v7]={};end local v1=require("ffi");local v2={};v1.cdef([[
    struct c_animstate {
        char pad[ 3 ];
        char m_bForceWeaponUpdate; //0x4
        char pad1[ 91 ];
        void* m_pBaseEntity; //0x60
        void* m_pActiveWeapon; //0x64
        void* m_pLastActiveWeapon; //0x68
        float m_flLastClientSideAnimationUpdateTime; //0x6C
        int m_iLastClientSideAnimationUpdateFramecount; //0x70
        float m_flAnimUpdateDelta; //0x74
        float m_flEyeYaw; //0x78
        float m_flPitch; //0x7C
        float m_flGoalFeetYaw; //0x80
        float m_flCurrentFeetYaw; //0x84
        float m_flCurrentTorsoYaw; //0x88
        float m_flUnknownVelocityLean; //0x8C
        float m_flLeanAmount; //0x90
        char pad2[ 4 ];
        float m_flFeetCycle; //0x98
        float m_flFeetYawRate; //0x9C
        char pad3[ 4 ];
        float m_fDuckAmount; //0xA4
        float m_fLandingDuckAdditiveSomething; //0xA8
        char pad4[ 4 ];
        float m_vOriginX; //0xB0
        float m_vOriginY; //0xB4
        float m_vOriginZ; //0xB8
        float m_vLastOriginX; //0xBC
        float m_vLastOriginY; //0xC0
        float m_vLastOriginZ; //0xC4
        float m_vVelocityX; //0xC8
        float m_vVelocityY; //0xCC
        char pad5[ 4 ];
        float m_flUnknownFloat1; //0xD4
        char pad6[ 8 ];
        float m_flUnknownFloat2; //0xE0
        float m_flUnknownFloat3; //0xE4
        float m_flUnknown; //0xE8
        float m_flSpeed2D; //0xEC
        float m_flUpVelocity; //0xF0
        float m_flSpeedNormalized; //0xF4
        float m_flFeetSpeedForwardsOrSideWays; //0xF8
        float m_flFeetSpeedUnknownForwardOrSideways; //0xFC
        float m_flTimeSinceStartedMoving; //0x100
        float m_flTimeSinceStoppedMoving; //0x104
        bool m_bOnGround; //0x108
        bool m_bInHitGroundAnimation; //0x109
        float m_flTimeSinceInAir; //0x10A
        float m_flLastOriginZ; //0x10E
        float m_flHeadHeightOrOffsetFromHittingGroundAnimation; //0x112
        float m_flStopToFullRunningFraction; //0x116
        char pad7[ 4 ]; //0x11A
        float m_flMagicFraction; //0x11E
        char pad8[ 60 ]; //0x122
        float m_flWorldForce; //0x15E
        char pad9[ 462 ]; //0x162
        float m_flMinYaw; //0x330
        float m_flMaxYaw; //0x334

        float velocity_subtract_x; //0x0330 
        float velocity_subtract_y; //0x0334 
        float velocity_subtract_z; //0x0338 
    };

    typedef void*(__thiscall* get_client_entity_t)(void*, int);

    typedef struct
    {
        float   m_anim_time;		
        float   m_fade_out_time;	
        int     m_flags;			
        int     m_activity;			
        int     m_priority;			
        int     m_order;			
        int     m_sequence;			
        float   m_prev_cycle;		
        float   m_weight;			
        float   m_weight_delta_rate;
        float   m_playback_rate;	
        float   m_cycle;			
        void* m_owner;			
        int     m_bits;				
    } C_AnimationLayer;

    typedef uintptr_t (__thiscall* GetClientEntityHandle_4242425_t)(void*, uintptr_t);
]]);function clamp(v9,v10,v11) return math.min(math.max(v9,v10),v11);end resolver={layers={[0]={},[1]={},[2]={},[3]={},[4]={},[5]={},[6]={},[7]={},[8]={},[9]={},[10]={},[11]={},[12]={},[13]={},[14]={},[15]={},[16]={},[17]={},[18]={},[19]={},[20]={},[21]={},[22]={},[23]={},[24]={},[25]={},[26]={},[27]={},[28]={},[29]={},[30]={},[31]={},[32]={},[33]={},[34]={},[35]={},[36]={},[37]={},[38]={},[39]={},[40]={},[40]={},[41]={},[42]={},[43]={},[44]={},[45]={},[46]={},[47]={},[48]={},[49]={},[50]={},[51]={},[52]={},[53]={},[54]={},[55]={},[56]={},[57]={},[58]={},[59]={},[60]={},[61]={},[62]={},[63]={},[64]={}},safepoints={},cache={}};function Approach(v12,v13,v14) v12=AngleModifier(v12);v13=AngleModifier(v13);local v15=v12-v13 ;if (v14<0) then v14= -v14;end if (v15< -180) then v15=v15 + 360 ;elseif (v15>180) then v15=v15-360 ;end if (v15>v14) then v13=v13 + v14 ;elseif (v15< -v14) then v13=v13-v14 ;else v13=v12;end return v13;end function NormalizeAngle(v16) if (v16==nil) then return 0;end while v16>180  do v16=v16-360 ;end while v16< -180  do v16=v16 + 360 ;end return v16;end function AngleDifference(v17,v18) local v19=math.fmod(v17-v18 ,360);if (v17>v18) then if (v19>=180) then v19=v19-360 ;end elseif (v19<= -180) then v19=v19 + 360 ;end return v19;end RawIEntityList=v1.cast("void***",client.create_interface("client.dll","VClientEntityList003"));IEntityList=v1.cast("GetClientEntityHandle_4242425_t",RawIEntityList[0][3]);function GetAddress(v20) if  not v20 then return;end return IEntityList(RawIEntityList,v20);end function GetAnimState(v21) if  not v21 then return;end return v1.cast("struct c_animstate**",GetAddress(v21) + 39264 )[0];end function GetMaxDesync(v22) local v23=GetAnimState(v22);if  not v23 then return 0;end local v24=clamp(v23.m_flFeetSpeedForwardsOrSideWays or 0 ,0,1);local v25=(((v23.m_flStopToFullRunningFraction *  -0.3) -0.2) * v24) + 1 ;local v26=v23.m_fDuckAmount;if (v26>0) then v25=v25 + (v26 * v24 * (0.5 -v25)) ;end return clamp(v25 or 0 ,0.5,1) or 0 ;end function GetSimulationTime(v27) local v28=GetAddress(v27);if (v28 and (v28~=nil)) then return entity.get_prop(player,"m_flSimulationTime",3),v1.cast("float*",v1.cast("uintptr_t",v28) + 620 )[0];else return 0;end end function GetChokedPackets(v29) local v30,v31=GetSimulationTime(v29);local v32=toticks(entity.get_prop(v29,"m_nTickBase")) -(v30 or 0) ;local v33=clamp(toticks(v32-client.latency() ) or 0 ,0,cvar['sv_maxusrcmdprocessticks']:get_string() -2 );return v33;end function AntiaimCorrection(v34,v35) if ( not v34 or  not entity.get_prop(v34,"m_angEyeAngles[1]") or  not client.current_threat() or  not globals.tickcount() or  not v35 or  not entity.get_local_player()) then return 0;end v0[v34][globals.tickcount()]=entity.get_prop(v34,"m_angEyeAngles[1]") or 0 ;return (v0[v34][globals.tickcount() -GetChokedPackets(v34) ] or v35) -v35 ;end function GetAnimlayers(v37,v38) if  not v37 then return;end return v1.cast("C_AnimationLayer**",v1.cast("uintptr_t",GetAddress(v37)) + 39264 )[0];end function AngleModifier(v39) return (360/65536) * bit.band(math.floor(v39 * (65536/360) ),65535) ;end function C_updateLayers(v40) resolver.layers[v40]=GetAnimlayers(v40);if  not resolver.layers[v40] then return;end for v93=1,12 do local v94=resolver.layers[v40][v93];if (v94 and v94.m_sequence and v94.m_playback_rate) then if  not resolver.layers[v40][v93] then resolver.layers[v40][v93]={};end resolver.layers[v40][v93].m_playback_rate=v94.m_playback_rate or resolver.layers[v40][v93].m_playback_rate ;resolver.layers[v40][v93].m_sequence=v94.m_sequence or resolver.layers[v40][v93].m_sequence ;break;end end end function C_updateSafety(v42,v43,v44) if ( not v42 or  not v43 or  not v44) then return;end if  not resolver.safepoints[v42] then resolver.safepoints[v42]={};end for v95=1,3 do if ((resolver.safepoints[v42][v95]==nil) or (resolver.safepoints[v42][v95].m_playback_rate==nil) or (resolver.safepoints[v42][v95].m_flDesync==nil)) then resolver.safepoints[v42][v95]={};resolver.safepoints[v42][v95].m_playback_rate=resolver.layers[v42][6].m_playback_rate;resolver.safepoints[v42][v95].m_flDesync=v44;end end if (v43<0) then resolver.safepoints[v42][3].m_flDesync= -v44;if (math.abs(resolver.safepoints[v42][3].m_flDesync)<=v44) then resolver.safepoints[v42][3].m_flDesync= -v44;resolver.safepoints[v42][3].m_playback_rate=resolver.layers[v42][6].m_playback_rate;end resolver.safepoints[v42][3].m_playback_rate=resolver.layers[v42][6].m_playback_rate;elseif (v43>0) then resolver.safepoints[v42][2].m_flDesync=v44;if (resolver.safepoints[v42][2].m_flDesync>=v44) then resolver.safepoints[v42][2].m_flDesync=v44;resolver.safepoints[v42][2].m_playback_rate=resolver.layers[v42][6].m_playback_rate;end resolver.safepoints[v42][2].m_playback_rate=resolver.layers[v42][6].m_playback_rate;else m_flDesync=v43 * v44 ;resolver.safepoints[v42][1].m_flDesync=m_flDesync;if (math.abs(resolver.safepoints[v42][1].m_flDesync)>=v44) then resolver.safepoints[v42][1].m_flDesync=m_flDesync;resolver.safepoints[v42][1].m_playback_rate=resolver.layers[v42][6].m_playback_rate;end resolver.safepoints[v42][1].m_playback_rate=resolver.layers[v42][6].m_playback_rate;end if (resolver.safepoints[v42][2].m_playback_rate and resolver.safepoints[v42][3].m_playback_rate) then m_flDesync=v43 * v44 ;if (m_flDesync>=resolver.safepoints[v42][3].m_flDesync) then if (m_flDesync<=resolver.safepoints[v42][2].m_flDesync) then resolver.safepoints[v42][1].m_flDesync=m_flDesync;if (math.abs(resolver.safepoints[v42][1].m_flDesync)>=v44) then resolver.safepoints[v42][1].m_flDesync=m_flDesync;resolver.safepoints[v42][1].m_playback_rate=resolver.layers[v42][6].m_playback_rate;end resolver.safepoints[v42][1].m_playback_rate=resolver.layers[v42][6].m_playback_rate;end end end end function C_Transition(v45,v46,v47,v48) local v49=false;local v50=true;local v51=2;local v52=260;local v53=0.34;local v54=0.52;if ((v45>0) and (v45<1)) then if (v46==v49) then v45=v45 + (v47 * v51) ;else v45=v45-(v47 * v51) ;end v45=clamp(v45,0,1);end if ((v48>(v52 * v54)) and (v46==v50)) then v46=v49;v45=math.max(0.01,v45);elseif ((v48<(v52 * v54)) and (v46==v49)) then v46=v50;v45=math.min(0.99,v45);end return v45,v46;end function C_predictedFootYaw(v55,v56,v57,v58,v59,v60,v61) local v62=math.min(v59,260);local v63=clamp(v55, -360,360);local v64=AngleDifference(v56,v63);if (v64>v61) then v63=v56-math.abs(v61) ;elseif (v64<v60) then v63=v56 + math.abs(v60) ;end v63=NormalizeAngle(v63);local v65=globals.tickinterval();if ((v62>0.1) or (v59>100)) then v63=Approach(v56,v63,v65 * (30 + (20 * v58)) );else v63=Approach(v57,v63,v65 * 100 );end return v63;end function C_ResolverInstance(v66) local v67=GetAnimState(v66);local v68=v66;if ( not entity.get_local_player() or  not entity.is_alive(entity.get_local_player())) then return 0;end if ( not v68 or  not entity.is_alive(v68) or  not v67) then return 0;end C_updateLayers(v66);if  not resolver.cache[v66] then resolver.cache[v66]={};end local v69=0;local v70=0;local v71=0;local v72=0;local v73=GetMaxDesync(v66);local v74=v73 * 57.2957795131 ;local v75=v67.m_flEyeYaw;local v76=AngleDifference(v75,plist.get(v66,"Force body yaw value"));local v77=math.abs(v76);local v78=v73 * v67.m_flMaxYaw ;local v79=v73 * v67.m_flMinYaw ;if (v76<0) then v69= -1;v71=1;elseif (v76>0) then v69=1;v71= -1;elseif (v76==0) then v69=v71;end if ((v77>0) or ((resolver.cache[v66].m_flAbsAngleDiff or 0)>0)) then m_flCurrentAngle=math.max(v77,resolver.cache[v66].m_flAbsAngleDiff or 1 );if ((v77<=10) and ((resolver.cache[v66].m_flAbsAngleDiff or 0)<=10)) then v74=m_flCurrentAngle;elseif ((v77<=35) and ((resolver.cache[v66].m_flAbsAngleDiff or 0)<=35)) then v74=math.max(29,m_flCurrentAngle);else v74=clamp(m_flCurrentAngle,29,57.2957795131);end end resolver.cache[v66].m_flAbsAngleDiff=v77;v74=clamp(v74,1,v73 * 57.2957795131 );C_updateSafety(v66,v69,v74);if ((v69~=0) and resolver.safepoints[v66]) then if (resolver.safepoints[v66][1] and resolver.safepoints[v66][2] and resolver.safepoints[v66][3]) then if (resolver.safepoints[v66][1].m_playback_rate and resolver.safepoints[v66][2].m_playback_rate and resolver.safepoints[v66][3].m_playback_rate) then local v142=resolver.layers[v66][6].m_playback_rate;local v143=resolver.safepoints[v66][1].m_playback_rate;local v144=resolver.safepoints[v66][2].m_playback_rate;local v145=resolver.safepoints[v66][3].m_playback_rate;local v146=math.abs(v142-v143 );local v147=math.abs(v142-v144 );local v148=math.abs(v142-v145 );if ((v147-v148)>v146) then v70=1;v72= -1;elseif ((v147-v148)~=v146) then v70= -1;v72=1;else v70=v72;end end end end local v81=entity.get_prop(v68,"m_vecVelocity");resolver.cache[v66].m_flWalkToRunTransition,resolver.cache[v66].m_bWalkToRunTransitionState=C_Transition(resolver.cache[v66].m_flWalkToRunTransition or 0 ,resolver.cache[v66].m_bWalkToRunTransitionState or false ,globals.tickinterval(),math.min(v81,260));v2[v66]=v74 * v70 ;return C_predictedFootYaw(plist.get(v66,"Force body yaw value"),v75-(v74 * v70) ,entity.get_prop(v68,"m_flLowerBodyYawTarget") -(v74 * v70) ,resolver.cache[v66].m_flWalkToRunTransition,v81,v79,v78);end resolver_mode=1;local v3={"AAI [main]","AAI [experem]","AAI [experem 2]","AAI [random]"};local v4=function(v85,v86,v87,v88) return string.format("%02x%02x%02x%02x",v85,v86,v87,v88);end;local v5="";for v89=1, #v3 do if (v89~= #v3) then v5=v5   .. v3[v89]   .. " or " ;else v5=v5   .. v3[v89] ;end end client.color_log(0,255,40,"[AAI RESOLVER] For switch resolver mode (on "   .. v5   .. ") write [!Switch rm] or [!switch resolver mode] or [!resolver] or [!rm]" );client.set_event_callback("console_input",function(v90) if ((v90:lower()=="!switch rm") or (v90:lower()=="!switch resolver mode") or (v90:lower()=="!resolver") or (v90:lower()=="!rm")) then resolver_mode=((resolver_mode< #v3) and (resolver_mode + 1)) or 1 ;print("Seccuses switched on "   .. v3[resolver_mode]   .. " method resolver" );end end);last_angles={};local v6=function(v91) return last_angles[v91] or entity.get_prop(player,"m_angEyeAngles[1]") or 0 ;end;function Resolving() local v92=entity.get_local_player();if  not v92 then return;end for v96,v97 in pairs(entity.get_players(true)) do local v98=GetAnimState(v97);if (resolver_mode==1) then if v98 then local v122=AntiaimCorrection(v97,v98.m_flEyeYaw);local v123=NormalizeAngle(C_ResolverInstance(v97) -v122 );if ((NormalizeAngle(C_ResolverInstance(v97) -v122 )>58) or (NormalizeAngle(C_ResolverInstance(v97) -v122 )< -58)) then plist.set(v97,"Force body yaw",false);else plist.set(v97,"Force body yaw",true);if (entity.get_steam64(v97)~=0) then plist.set(v97,"Force body yaw value",clamp( -58,v123,58));else plist.set(v97,"Force body yaw value",0);end end end elseif (resolver_mode==2) then if (entity.is_dormant(v97) or  not entity.is_alive(v97) or  not v98) then return;end local v124=v98.m_flGoalFeetYaw;local v125=entity.get_prop(v97,"m_angEyeAngles[1]") or 0 ;local v126=entity.get_prop(v97,"m_vecVelocity[0]") or 0 ;local v127=v6(v97);local v128=v127 or v125 ;local v129=NormalizeAngle(v125-v124 );if (math.abs(v129)>35) then v128=v124;end local v130=math.min(math.abs(v126)/260 ,1);v128=(v128 * (1 -(v130 * 0.5))) + (v124 * v130 * 0.5) ;local v131=NormalizeAngle(v128-v127 );if (math.abs(v131)>10) then v128=v127 + (v131 * 0.25) ;else v128=v127 + (v131 * 0.5) ;end last_angles[v97]=(v129/2) + v131 ;plist.set(v97,"Force body yaw",true);plist.set(v97,"Force body yaw value",clamp( -58,58,NormalizeAngle(v128)));elseif (resolver_mode==3) then local v149=entity.get_prop(v97,"m_angEyeAngles[1]");plist.set(v97,"Force body yaw",true);local v150=v98.m_flGoalFeetYaw;plist.set(v97,"Force body yaw value",clamp( -58,58,NormalizeAngle(v149-v150 )));elseif (resolver_mode==4) then local v154=entity.get_prop(v97,"m_angEyeAngles[1]");plist.set(v97,"Force body yaw",true);local v155=v98.m_flGoalFeetYaw;plist.set(v97,"Force body yaw value",clamp( -58,58,NormalizeAngle(v154-v155 ) * math.random( -1,1) ));end end end client.set_event_callback("net_update_start",function() if ( not entity.get_local_player() or  not entity.is_alive(entity.get_local_player()) or  not client.current_threat()) then return;end Resolving();end);misses_r,hit_r=0,0;client.set_event_callback("aim_miss",function() misses_r=misses_r + 1 ;end);client.set_event_callback("aim_hit",function() hit_r=hit_r + 1 ;end);client.set_event_callback("round_end",function() if (((misses_r + 1)<hit_r) and ((misses_r + 1)>1)) then print("Didn't reseting memory. Hitrate is normal.");return;end print("Clear merory [Round end]");for v99=1,64 do v0[v99]={};end misses_r=0;hit_r=0;end);
