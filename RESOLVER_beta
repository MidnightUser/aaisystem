local Yaw_cache = {}
for i = 1, 64 do Yaw_cache[i] = {}end
local ffi = require 'ffi'
local m_flDesync_c = {}
ffi.cdef([[
    struct c_animstate {
        char pad[ 3 ];
        char m_bForceWeaponUpdate; //0x4
        char pad1[ 91 ];
        void* m_pBaseEntity; //0x60
        void* m_pActiveWeapon; //0x64
        void* m_pLastActiveWeapon; //0x68
        float m_flLastClientSideAnimationUpdateTime; //0x6C
        int m_iLastClientSideAnimationUpdateFramecount; //0x70
        float m_flAnimUpdateDelta; //0x74
        float m_flEyeYaw; //0x78
        float m_flPitch; //0x7C
        float m_flGoalFeetYaw; //0x80
        float m_flCurrentFeetYaw; //0x84
        float m_flCurrentTorsoYaw; //0x88
        float m_flUnknownVelocityLean; //0x8C
        float m_flLeanAmount; //0x90
        char pad2[ 4 ];
        float m_flFeetCycle; //0x98
        float m_flFeetYawRate; //0x9C
        char pad3[ 4 ];
        float m_fDuckAmount; //0xA4
        float m_fLandingDuckAdditiveSomething; //0xA8
        char pad4[ 4 ];
        float m_vOriginX; //0xB0
        float m_vOriginY; //0xB4
        float m_vOriginZ; //0xB8
        float m_vLastOriginX; //0xBC
        float m_vLastOriginY; //0xC0
        float m_vLastOriginZ; //0xC4
        float m_vVelocityX; //0xC8
        float m_vVelocityY; //0xCC
        char pad5[ 4 ];
        float m_flUnknownFloat1; //0xD4
        char pad6[ 8 ];
        float m_flUnknownFloat2; //0xE0
        float m_flUnknownFloat3; //0xE4
        float m_flUnknown; //0xE8
        float m_flSpeed2D; //0xEC
        float m_flUpVelocity; //0xF0
        float m_flSpeedNormalized; //0xF4
        float m_flFeetSpeedForwardsOrSideWays; //0xF8
        float m_flFeetSpeedUnknownForwardOrSideways; //0xFC
        float m_flTimeSinceStartedMoving; //0x100
        float m_flTimeSinceStoppedMoving; //0x104
        bool m_bOnGround; //0x108
        bool m_bInHitGroundAnimation; //0x109
        float m_flTimeSinceInAir; //0x10A
        float m_flLastOriginZ; //0x10E
        float m_flHeadHeightOrOffsetFromHittingGroundAnimation; //0x112
        float m_flStopToFullRunningFraction; //0x116
        char pad7[ 4 ]; //0x11A
        float m_flMagicFraction; //0x11E
        char pad8[ 60 ]; //0x122
        float m_flWorldForce; //0x15E
        char pad9[ 462 ]; //0x162
        float m_flMinYaw; //0x330
        float m_flMaxYaw; //0x334

        float velocity_subtract_x; //0x0330 
        float velocity_subtract_y; //0x0334 
        float velocity_subtract_z; //0x0338 
    };

    typedef void*(__thiscall* get_client_entity_t)(void*, int);

    typedef struct
    {
        float   m_anim_time;		
        float   m_fade_out_time;	
        int     m_flags;			
        int     m_activity;			
        int     m_priority;			
        int     m_order;			
        int     m_sequence;			
        float   m_prev_cycle;		
        float   m_weight;			
        float   m_weight_delta_rate;
        float   m_playback_rate;	
        float   m_cycle;			
        void* m_owner;			
        int     m_bits;				
    } C_AnimationLayer;

    typedef uintptr_t (__thiscall* GetClientEntityHandle_4242425_t)(void*, uintptr_t);
]])
function clamp(value, min, max)
    return math.min(math.max(value, min), max)
end
resolver = {layers = {[0] = {}, [1] = {}, [2] = {}, [3] = {}, [4] = {}, [5] = {}, [6] = {}, [7] = {}, [8] = {}, [9] = {}, [10] = {}, [11] = {}, [12] = {}, [13] = {}, [14] = {}, [15] = {}, [16] = {}, [17] = {}, [18] = {}, [19] = {}, [20] = {}, [21] = {}, [22] = {}, [23] = {}, [24] = {}, [25] = {}, [26] = {}, [27] = {}, [28] = {}, [29] = {}, [30] = {}, [31] = {}, [32] = {}, [33] = {}, [34] = {}, [35] = {}, [36] = {}, [37] = {}, [38] = {}, [39] = {}, [40] = {}, [40] = {}, [41] = {}, [42] = {}, [43] = {}, [44] = {}, [45] = {}, [46] = {}, [47] = {}, [48] = {}, [49] = {}, [50] = {}, [51] = {}, [52] = {}, [53] = {}, [54] = {}, [55] = {}, [56] = {}, [57] = {}, [58] = {}, [59] = {}, [60] = {}, [61] = {}, [62] = {}, [63] = {}, [64] = {}}, safepoints = {},cache = {}}
function Approach(target, value, speed)
	target = AngleModifier(target)
	value = AngleModifier(value)
	local delta = target - value
	if speed < 0 then
        speed = -speed
    end
	if delta < -180 then
        delta = delta + 360
	elseif delta > 180 then
        delta = delta - 360
    end
	if delta > speed then
        value = value + speed
	elseif delta < -speed then
        value = value - speed
    else
        value = target
	end
	return value
end
function NormalizeAngle(angle)
    if angle == nil then
        return 0
    end
	while angle > 180 do
        angle = angle - 360
    end
	while angle < -180 do
        angle = angle + 360
    end
	return angle
end
function AngleDifference(dest_angle, src_angle)
	local delta = math.fmod(dest_angle - src_angle, 360)
	if dest_angle > src_angle then
		if delta >= 180 then
            delta = delta - 360
        end
	else
		if delta <= -180 then
            delta = delta + 360
        end
	end
	return delta
end
RawIEntityList = ffi.cast("void***", client.create_interface("client.dll","VClientEntityList003"))
IEntityList = ffi.cast("GetClientEntityHandle_4242425_t", RawIEntityList[0][3])
function GetAddress(idx)
    if not idx then
        return
    end
    return IEntityList(RawIEntityList, idx)
end
GetAnimState = function(ent)
    if not ent then
        return
    end
    return ffi.cast("struct c_animstate**", GetAddress(ent) + 0x9960)[0]
end
GetMaxDesync = function(player)
    local Animstate = GetAnimState(player)
    if not Animstate then
        return 0
    end
    local speedfactor = clamp(Animstate.m_flFeetSpeedForwardsOrSideWays or 0, 0, 1)
    local avg_speedfactor = (Animstate.m_flStopToFullRunningFraction * -0.3 - 0.2) * speedfactor + 1
    local duck_amount = Animstate.m_fDuckAmount
    if duck_amount > 0 then avg_speedfactor = avg_speedfactor + ((duck_amount * speedfactor) * (0.5 - avg_speedfactor)) end
    return clamp(avg_speedfactor or 0, 0.5, 1) or 0
end
GetSimulationTime = function(ent)
    local pointer = GetAddress(ent)
    if pointer and pointer ~= nil then
        return entity.get_prop(player, "m_flSimulationTime", 3), ffi.cast("float*", ffi.cast("uintptr_t", pointer) + 0x26C)[0]
    else
        return 0
    end
end
GetChokedPackets = function(player)
    local CurrentSimulationTime, PreviousSimulationTime = GetSimulationTime(player)
    local SimulationTimeDifference = toticks(entity.get_prop(player, "m_nTickBase")) - (CurrentSimulationTime or 0)
    local ChokedCommands = clamp(toticks(SimulationTimeDifference - client.latency()) or 0, 0, cvar["sv_maxusrcmdprocessticks"]:get_string() - 2)
    return ChokedCommands
end
function AntiaimCorrection(idx, m_flEyeYaw)
	if not idx or not entity.get_prop(idx, "m_angEyeAngles[1]") or not client.current_threat() or not globals.tickcount() or not m_flEyeYaw or not entity.get_local_player() then return 0 end
    Yaw_cache[idx][globals.tickcount()] = entity.get_prop(idx, "m_angEyeAngles[1]") or 0
    return (Yaw_cache[idx][globals.tickcount() - GetChokedPackets(idx)] or m_flEyeYaw) - m_flEyeYaw
end
GetAnimlayers = function (ent, layer)
    if not ent then
        return
    end
    return ffi.cast("C_AnimationLayer**", ffi.cast('uintptr_t', GetAddress(ent)) + 0x9960)[0]
end
function AngleModifier(a)
    return (360 / 65536) * bit.band(math.floor(a * (65536 / 360)), 65535)
end
C_updateLayers = function(idx)
    resolver.layers[idx] = GetAnimlayers(idx)
    if not resolver.layers[idx] then
        return
    end
    for i = 1, 12 do
        local layer = resolver.layers[idx][i]
        if layer and layer.m_sequence and layer.m_playback_rate then
            if not resolver.layers[idx][i] then
                resolver.layers[idx][i] = {}
            end
            resolver.layers[idx][i].m_playback_rate = layer.m_playback_rate or resolver.layers[idx][i].m_playback_rate
            resolver.layers[idx][i].m_sequence = layer.m_sequence or resolver.layers[idx][i].m_sequence
            break
        end
    end
end
C_updateSafety = function(idx, side, desync)
    if not idx or not side or not desync then
        return
    end
    if not resolver.safepoints[idx] then
        resolver.safepoints[idx] = {}
    end
    for i = 1, 3 do
        if resolver.safepoints[idx][i] == nil or resolver.safepoints[idx][i].m_playback_rate == nil or resolver.safepoints[idx][i].m_flDesync == nil then
            resolver.safepoints[idx][i] = {}
            resolver.safepoints[idx][i].m_playback_rate = resolver.layers[idx][6].m_playback_rate
            resolver.safepoints[idx][i].m_flDesync = desync
        end
    end
    if side < 0 then
        resolver.safepoints[idx][3].m_flDesync = -desync
        if math.abs(resolver.safepoints[idx][3].m_flDesync) <= desync then
            resolver.safepoints[idx][3].m_flDesync = -desync
            resolver.safepoints[idx][3].m_playback_rate = resolver.layers[idx][6].m_playback_rate
        end
        resolver.safepoints[idx][3].m_playback_rate = resolver.layers[idx][6].m_playback_rate
    elseif side > 0 then
        resolver.safepoints[idx][2].m_flDesync = desync
        if resolver.safepoints[idx][2].m_flDesync >= desync then
            resolver.safepoints[idx][2].m_flDesync = desync
            resolver.safepoints[idx][2].m_playback_rate = resolver.layers[idx][6].m_playback_rate
        end
        resolver.safepoints[idx][2].m_playback_rate = resolver.layers[idx][6].m_playback_rate
    else
        m_flDesync = side * desync
        resolver.safepoints[idx][1].m_flDesync = m_flDesync
        if math.abs(resolver.safepoints[idx][1].m_flDesync) >= desync then
            resolver.safepoints[idx][1].m_flDesync = m_flDesync
            resolver.safepoints[idx][1].m_playback_rate = resolver.layers[idx][6].m_playback_rate
        end
        resolver.safepoints[idx][1].m_playback_rate = resolver.layers[idx][6].m_playback_rate
    end
    if resolver.safepoints[idx][2].m_playback_rate and resolver.safepoints[idx][3].m_playback_rate then
        m_flDesync = side * desync
        if m_flDesync >= resolver.safepoints[idx][3].m_flDesync then
            if m_flDesync <= resolver.safepoints[idx][2].m_flDesync then
                resolver.safepoints[idx][1].m_flDesync = m_flDesync
                if math.abs(resolver.safepoints[idx][1].m_flDesync) >= desync then
                    resolver.safepoints[idx][1].m_flDesync = m_flDesync
                    resolver.safepoints[idx][1].m_playback_rate = resolver.layers[idx][6].m_playback_rate
                end
                resolver.safepoints[idx][1].m_playback_rate = resolver.layers[idx][6].m_playback_rate 
            end
        end
    end
end
C_Transition = function(m_flWalkToRunTransition, m_bWalkToRunTransitionState, m_flLastUpdateIncrement, m_flVelocityLengthXY)
    local ANIM_TRANSITION_WALK_TO_RUN = false
    local ANIM_TRANSITION_RUN_TO_WALK = true
    local CSGO_ANIM_WALK_TO_RUN_TRANSITION_SPEED = 2.0
    local CS_PLAYER_SPEED_RUN = 260.0
    local CS_PLAYER_SPEED_DUCK_MODIFIER = 0.34
    local CS_PLAYER_SPEED_WALK_MODIFIER = 0.52
    if m_flWalkToRunTransition > 0 and m_flWalkToRunTransition < 1 then
        if m_bWalkToRunTransitionState == ANIM_TRANSITION_WALK_TO_RUN then
            m_flWalkToRunTransition = m_flWalkToRunTransition + m_flLastUpdateIncrement * CSGO_ANIM_WALK_TO_RUN_TRANSITION_SPEED
        else
            m_flWalkToRunTransition = m_flWalkToRunTransition - m_flLastUpdateIncrement * CSGO_ANIM_WALK_TO_RUN_TRANSITION_SPEED
        end
        m_flWalkToRunTransition = clamp(m_flWalkToRunTransition, 0, 1)
    end
    if m_flVelocityLengthXY > (CS_PLAYER_SPEED_RUN * CS_PLAYER_SPEED_WALK_MODIFIER) and m_bWalkToRunTransitionState == ANIM_TRANSITION_RUN_TO_WALK then
        m_bWalkToRunTransitionState = ANIM_TRANSITION_WALK_TO_RUN
        m_flWalkToRunTransition = math.max(0.01, m_flWalkToRunTransition)
    elseif m_flVelocityLengthXY < (CS_PLAYER_SPEED_RUN * CS_PLAYER_SPEED_WALK_MODIFIER) and m_bWalkToRunTransitionState == ANIM_TRANSITION_WALK_TO_RUN then
        m_bWalkToRunTransitionState = ANIM_TRANSITION_RUN_TO_WALK
        m_flWalkToRunTransition = math.min(0.99, m_flWalkToRunTransition)
    end
    return m_flWalkToRunTransition, m_bWalkToRunTransitionState
end
C_predictedFootYaw = function(m_flFootYawLast, m_flEyeYaw, m_flLowerBodyYawTarget, m_flWalkToRunTransition, m_vecVelocity, m_flMinBodyYaw, m_flMaxBodyYaw)
    local m_flVelocityLengthXY = math.min((m_vecVelocity), 260.0)
    local m_flFootYaw = clamp(m_flFootYawLast, -360, 360)
    local flEyeFootDelta = AngleDifference(m_flEyeYaw, m_flFootYaw)
    if flEyeFootDelta > m_flMaxBodyYaw then
        m_flFootYaw = m_flEyeYaw - math.abs(m_flMaxBodyYaw)
    elseif flEyeFootDelta < m_flMinBodyYaw then
        m_flFootYaw = m_flEyeYaw + math.abs(m_flMinBodyYaw)
    end
    m_flFootYaw = NormalizeAngle(m_flFootYaw)
    local m_flLastUpdateIncrement = globals.tickinterval()
    if m_flVelocityLengthXY > 0.1 or m_vecVelocity > 100 then
        m_flFootYaw = Approach(m_flEyeYaw, m_flFootYaw, m_flLastUpdateIncrement * (30.0 + 20.0 * m_flWalkToRunTransition))
    else
        m_flFootYaw = Approach(m_flLowerBodyYawTarget, m_flFootYaw, m_flLastUpdateIncrement * 100)
    end

    return m_flFootYaw
end
C_ResolverInstance = function(idx)
    local animstate = GetAnimState(idx)
    local ent = idx
    if not entity.get_local_player() or not entity.is_alive(entity.get_local_player())then
        return 0
    end
    if not ent or not entity.is_alive(ent) or not animstate then
        return 0
    end
    C_updateLayers(idx)
    if not resolver.cache[idx] then
        resolver.cache[idx] = {}
    end
    local side = 0
    local side2 = 0
    local latest = 0
    local latest2 = 0
    local m_flMaxDesyncDelta = GetMaxDesync(idx)
    local m_flDesync = m_flMaxDesyncDelta * 57.2957795131
    local m_flEyeYaw = animstate.m_flEyeYaw
    local m_flAngleDiff = AngleDifference(m_flEyeYaw, plist.get(idx, "Force body yaw value"))
    local m_flAbsAngleDiff = math.abs(m_flAngleDiff)
	local m_flMaxYawModifier = m_flMaxDesyncDelta * animstate.m_flMaxYaw
    local m_flMinYawModifier = m_flMaxDesyncDelta * animstate.m_flMinYaw
    if m_flAngleDiff < 0 then
        side = -1
        latest = 1
    elseif m_flAngleDiff > 0 then
        side = 1
        latest = -1
    elseif m_flAngleDiff == 0 then
        side = latest
    end
    if m_flAbsAngleDiff > 0 or (resolver.cache[idx].m_flAbsAngleDiff or 0) > 0 then
        m_flCurrentAngle = math.max(m_flAbsAngleDiff, resolver.cache[idx].m_flAbsAngleDiff or 1)
        if m_flAbsAngleDiff <= 10 and (resolver.cache[idx].m_flAbsAngleDiff or 0) <= 10 then
            m_flDesync = m_flCurrentAngle
        elseif m_flAbsAngleDiff <= 35 and (resolver.cache[idx].m_flAbsAngleDiff or 0) <= 35 then
            m_flDesync = math.max(29, m_flCurrentAngle)
        else
            m_flDesync = clamp(m_flCurrentAngle, 29, 57.2957795131)
        end
    end
    resolver.cache[idx].m_flAbsAngleDiff = m_flAbsAngleDiff
    m_flDesync = clamp(m_flDesync, 1, m_flMaxDesyncDelta * 57.2957795131)
    C_updateSafety(idx, side, m_flDesync)
    if side ~= 0 and resolver.safepoints[idx] then
        if resolver.safepoints[idx][1] and resolver.safepoints[idx][2] and resolver.safepoints[idx][3] then
            if resolver.safepoints[idx][1].m_playback_rate and resolver.safepoints[idx][2].m_playback_rate and resolver.safepoints[idx][3].m_playback_rate then
                local server_playback = resolver.layers[idx][6].m_playback_rate
                local center_playback = resolver.safepoints[idx][1].m_playback_rate
                local left_playback = resolver.safepoints[idx][2].m_playback_rate
                local right_playback = resolver.safepoints[idx][3].m_playback_rate
                local m_layer_delta1 = math.abs(server_playback - center_playback)
                local m_layer_delta2 = math.abs(server_playback - left_playback)
                local m_layer_delta3 = math.abs(server_playback - right_playback)
                if m_layer_delta2 - m_layer_delta3 > m_layer_delta1 then
                    side2 = 1
                    latest2 = -1
                else
                    if m_layer_delta2 - m_layer_delta3 ~= m_layer_delta1 then
                        side2 = -1
                        latest2 = 1
                    else
                        side2 = latest2
                    end
                end
            end
        end
    end
    local m_vecVelocity = entity.get_prop(ent, "m_vecVelocity")
    resolver.cache[idx].m_flWalkToRunTransition, resolver.cache[idx].m_bWalkToRunTransitionState = C_Transition(resolver.cache[idx].m_flWalkToRunTransition or 0, resolver.cache[idx].m_bWalkToRunTransitionState or false, globals.tickinterval(), math.min((m_vecVelocity), 260))
    m_flDesync_c[idx] = m_flDesync * side2
    return C_predictedFootYaw(plist.get(idx, "Force body yaw value"), m_flEyeYaw - m_flDesync * side2, entity.get_prop(ent, "m_flLowerBodyYawTarget") - m_flDesync * side2, resolver.cache[idx].m_flWalkToRunTransition, m_vecVelocity, m_flMinYawModifier, m_flMaxYawModifier)
end
resolver_mode = 1
local modes = {"AAI [main]", "AAI [experem]", "AAI [random]"}
local rgba_to_hex = function(r, g, b, a)
    return string.format('%02x%02x%02x%02x', r, g, b, a)
end
local modes_text = ""
for i = 1, #modes do
	if i ~= #modes then
		modes_text = modes_text..modes[i].." or "
	else
		modes_text = modes_text..modes[i]
	end
end
client.color_log(0,255,40,"[AAI RESOLVER] For switch resolver mode (on "..modes_text..") write [!Switch rm] or [!switch resolver mode] or [!resolver] or [!rm]")
client.set_event_callback("console_input", function(text)
	if text:lower() == "!switch rm" or text:lower() == "!switch resolver mode" or text:lower() == "!resolver" or text:lower() == "!rm" then
		resolver_mode = resolver_mode < #modes and resolver_mode + 1 or 1
		print("Seccuses switched on "..(modes[resolver_mode]).." method resolver")
	end
end)
last_angles = {}
local get_last_angles = function(pl)
	return last_angles[pl] or entity.get_prop(player, "m_angEyeAngles[1]") or 0
end
function Resolving()
    local lp = entity.get_local_player()
    if not lp then return end
	for _, player in pairs(entity.get_players(true)) do
		local animstate = GetAnimState(player)
		if resolver_mode == 1 then
			if animstate then
				local JitterCorrection = AntiaimCorrection(player, animstate.m_flEyeYaw)
				local bodyaw_correnction = NormalizeAngle(C_ResolverInstance(player) - JitterCorrection)
				if NormalizeAngle(C_ResolverInstance(player) - JitterCorrection) > 58 or NormalizeAngle(C_ResolverInstance(player) - JitterCorrection) < -58 then
					plist.set(player, "Force body yaw", false)
				else
					plist.set(player, "Force body yaw", true)
					if entity.get_steam64(player) ~= 0 then
						plist.set(player, "Force body yaw value", clamp(-58, bodyaw_correnction, 58))
					else
						plist.set(player, "Force body yaw value", 0)
					end
				end
			end
		elseif resolver_mode == 2 then
			if entity.is_dormant(player) or not entity.is_alive(player) or not animstate then return end
			
			local goal_feet_yaw = animstate.m_flGoalFeetYaw
			local eye_yaw = entity.get_prop(player, "m_angEyeAngles[1]") or 0
			local speed = entity.get_prop(player, "m_vecVelocity[0]") or 0
			
			local last_angle = get_last_angles(player)
			local predicted_yaw = last_angle or eye_yaw
			
			local delta_yaw = NormalizeAngle(eye_yaw - goal_feet_yaw)
			if math.abs(delta_yaw) > 35 then
				predicted_yaw = goal_feet_yaw
			end
			
			local normalized_speed = math.min(math.abs(speed) / 260, 1)
			predicted_yaw = predicted_yaw * (1 - normalized_speed * 0.5) + goal_feet_yaw * (normalized_speed * 0.5)
			
			local angle_delta = NormalizeAngle(predicted_yaw - last_angle)
				
			if math.abs(angle_delta) > 10 then
				predicted_yaw = last_angle + angle_delta * 0.25
			else
				predicted_yaw = last_angle + angle_delta * 0.5
			end
			
			last_angles[player] = (delta_yaw / 2) + angle_delta

			plist.set(player, "Force body yaw", true)
			plist.set(player, "Force body yaw value", clamp(-58, 58, NormalizeAngle(predicted_yaw)))
		elseif resolver_mode == 3 then
			local eye_yaw = entity.get_prop(player, "m_angEyeAngles[1]")
			plist.set(player, "Force body yaw", true)
			local goal_feet_yaw = animstate.m_flGoalFeetYaw
			plist.set(player, "Force body yaw value", clamp(-58, 58, NormalizeAngle(eye_yaw-goal_feet_yaw)*math.random(-1,1)))
        end
	end
end
client.set_event_callback("net_update_start", function()
	if not entity.get_local_player() or not entity.is_alive(entity.get_local_player()) or not client.current_threat() then return end
	Resolving()
end)

misses_r, hit_r = 0, 0
client.set_event_callback("aim_miss", function()
	misses_r = misses_r + 1
end)
client.set_event_callback("aim_hit", function()
	hit_r = hit_r + 1
end)
client.set_event_callback("round_end", function()
	if misses_r+1 < hit_r and misses_r+1 > 1 then print("Didn't reseting memory. Hitrate is normal.") return end
	print("Clear merory [Round end]")
	for i = 1, 64 do Yaw_cache[i] = {}end
	misses_r = 0 hit_r = 0
end)
